---
title: 算法导论学习之红黑树(1)
date: 2015-07-20 18:24:33
tags:
	algorithm
---

## 写在前面的话

花了三天时间，将将实现了红黑树算法，但还是不能裸写红黑树，起码要看着算导书上的示意图::>_<:: 整个算法确实算比较复杂的，实现代码比普通二叉树多一倍多，但换来的是效率上的提升。废话不多说，总结一下学习心得（基本的细节不会提到，因为可以去翻书，我只写出对书中个别知识点的理解和总结），方便日后会看红黑树时，能立马回忆起来。

<!-- more -->

### 红黑树的性质

1. 每个节点要么是红的， 要么是黑的；
2. 根节点是黑的；
3. 每个叶节点（NIL）是黑的；
4. 如果一个节点是红的，那么它的两个儿子是黑的；
5. 对每个节点，从该节点到其子孙节点的所有路径上包含数目相同的黑节点。


以上四条性质都很好理解，唯独就是第五条不好理解，我觉得是翻译的不好。如果不亲自去实现一遍这个算法，对第五条性质中的“子孙节点”的理解是会有歧义的。比如，我初次看到这条性质的时候，我将该节点的子孙节点理解成为该节点的儿子节点+孙子节点+曾孙子节点+……+叶节点，汉语中确实是这么个意思嘛，但实际上是指沿着该节点下去的能达到的所有叶子节点。

{%img http://xijun-album.oss-cn-hangzhou.aliyuncs.com/rbtree1/img1.jpeg %}

图1 一棵标准的红黑树

如图所示，这是一棵标准的红黑树。针对性质5），我们从图中根节点26出发，很容易验证到达其叶子节点nil[T]的所有路径中经过的黑节点数都是4（当然包括它本身）。再拿节点21做例子，从节点21出发到达叶子节点的所有路径中经过的黑节点数都是3。这才是性质5）想要表达的意思，因此，我将性质5）转述成了如下：
性质5）对于每个节点，从该节点到叶子节点nil[T]的所有路径上包含相同数目的黑节点。
有了对上述五条性质的正确理解，才能搞得懂后面那些操作算法，因为这些算法的正确性需要有这些性质做保证。

### 局部旋转

{%img http://xijun-album.oss-cn-hangzhou.aliyuncs.com/rbtree1/img2.jpeg %}

图2 旋转操作

旋转操作还是很简单的，所以不去赘述其细节，但在具体实现的时候要注意两点：

1. 节点之间的连接关系的建立与删除最好是成对地去处理；
2. 若旋转前的父节点x是整棵树的根节点，旋转之后，要记得将树的根节点置为y。

### 插入操作

先给出算法导论书上的伪代码：

```c
RB-INSERT(T,z)伪代码
  y <- nil[T]
  x <- root[T]
  while x != nil[T]
  y <- x
  if key[x] > key[z]
    then x <- left[x]
    else x<- right[x]
  p[z] <- y
  if y == nil[T]
  then root[T] <- z
  else if key[z] < key[y]
      then left[y] <- z
      else right[y] <- z
 left[z] <- nil[T]
 right[z] <- nil[T]
 color[z] <- RED
 RB-INSERT-FIXUP(T,z)
 ```

从上述伪代码可以看出，红黑树的插入操作与普通二叉树的插入操作的差别很小，我们可以注意到插入的新节点的颜色居然是红色，为什么是红色呢？其实很容易想得通，如果插入的新节点就是黑色的话，那么会改变某个节点的黑高度，因此违反了性质5），往往涉及到黑节点的处理都会比较复杂。因此算导选择插入的新节点一开始就将它设置为红色的，但这样子也可能违反性质2）、4），因此需要有一个辅助程序RB-INSERT-FIXUP来修补可能违反的性质。

RB-INSERT-FIXUP修补可能违反的性质4），z指向插入的红色节点，因为违反了性质4），所以p[z]也是红的。可以将违反性质4）的情况归结为三种（其实，不止三种，是六种，另外三种可以通过对称关系得到。）

```c
RB-INSERT-FIXUP(T,z)伪代码
  while color[p[z]] == RED
  if p[z] == left[p[p[z]]
    then y <- right[p[p[z]]
     if color[y] == RED                                                    //case1
       then color[p[z]] <- BLACK                                           //case1
           color[y] <- BLACK                                             //case1
           color[p[p[z]] <- RED                                            //case1
           z <- p[p[z]]                                                    //case1
       else if z == right[p[z]]                                               //case2
           then z <- p[z]                                                 //case2
           LEFT-ROTATE(T,z)                                            //case2
              color[p[z]] <- BLACK                                      //case 3
              color[p[p[z]] <- RED                                       //case 3
              RIGHT-ROTATE(T,p[p[z]])                                 //case 3
     else (same as then clause with “right” and “lefet” exchange)
  color[root[T]] <- BLACK
```

{%img http://xijun-album.oss-cn-hangzhou.aliyuncs.com/rbtree1/img3.jpeg %}

图3 插入操作中可能遇到的三种情况

1. z的叔叔y是红色的。
处理方法：很简单，将z的祖父染成红色，将其父亲和叔父染成黑色，这样就解决了z的红色与其父亲也是红色的冲突。（那么其祖父先前就会是黑色的吗？答案是一定的，因为z的父亲和叔叔都是红色的，而未加入红节点z之前该树是满足红黑性质的，因此z的祖父一定是黑色的，如果z的祖父也是红的话，那么就与z父亲是红色的冲突了。）z指向其原来祖父，这样指针沿着树上升了两层。并且所有情况中，只有情况1会使得指针z上升两层。
2. z的叔叔y是黑色的，z是其父亲的右孩子。
处理方法：将z的父亲右旋即可，z指向原先z的父亲。经过旋转变换后，现在的z是其父亲的左儿子，并且它的叔叔是黑色的，那么情况2就转换为了情况3。
3. z的叔叔y是黑色的，z是其父亲的左孩子。
处理方法：通过情况1或者情况2都可能进到情况3。因为在这个情况下，z及其父亲p[z]都是红色。故先将其父亲p[z]染成黑色，将其祖父p[p[z]]染成红色，然后对祖父节点p[p[z]]做右旋。

其余的三种情况与上述三种情况是相互对称的。上述三种情况的转化关系如下：

{%img http://xijun-album.oss-cn-hangzhou.aliyuncs.com/rbtree1/img4.jpeg %}

最后，值得注意的是退出while循环时，需要置根节点的颜色为黑色。因为while循环条件是z的父亲p[z]为红色的，当z指向树的根时，z的父亲是nil[T]为黑色，故会退出循环，但是z的颜色为红色，因此需要置其颜色为黑色，这样就不违反性质2）了。

